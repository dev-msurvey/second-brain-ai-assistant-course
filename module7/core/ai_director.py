"""
Module 7: AI Director Orchestrator
==================================

Main orchestrator that coordinates all AI Director modules.

Components:
- Module 4: LLM (Fine-tuned model for strategy generation)
- Module 5: Vector RAG (Brand context retrieval)
- Module 6: Production Tools (Image/Voice/Video generation)
- Module 6.5: Smart Cut (Video editing)

Author: AI Director Team
License: MIT
"""

import logging
from typing import Dict, Any, Optional, List
from pathlib import Path
import json
import time
from dataclasses import dataclass, asdict
from datetime import datetime

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


@dataclass
class DirectorConfig:
    """Configuration for AI Director."""
    # Module 5: Vector RAG
    mongodb_uri: Optional[str] = None
    mongodb_database: str = "ai_director"
    mongodb_collection: str = "brand_vectors"
    retrieval_method: str = "hybrid"  # "vector", "bm25", "hybrid"
    top_k: int = 3
    
    # Module 6: Production Tools
    hf_token: Optional[str] = None
    image_model: str = "sdxl"
    voice_language: str = "thai"
    video_fps: int = 30
    
    # Module 6.5: Smart Cut
    scene_detection_method: str = "content"
    remove_silence: bool = True
    
    # General
    output_dir: str = "output"
    temp_dir: str = "temp"
    cache_enabled: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary."""
        return asdict(self)


@dataclass
class Brief:
    """Content brief from user."""
    brand: str
    product: str
    duration: float  # seconds
    platform: str  # "instagram", "youtube", "tiktok", etc.
    language: str = "thai"
    tone: str = "professional"
    additional_notes: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert brief to dictionary."""
        return asdict(self)


@dataclass
class CreativeStrategy:
    """Creative strategy generated by LLM."""
    concept: str
    visual_scenes: List[str]
    script: str
    music_mood: Optional[str] = None
    color_palette: Optional[List[str]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert strategy to dictionary."""
        return asdict(self)


@dataclass
class ContentOutput:
    """Final content output."""
    video_path: str
    images: List[str]
    audio_path: str
    duration: float
    metadata: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert output to dictionary."""
        return asdict(self)


class AIDirector:
    """
    AI Director Orchestrator - Coordinates all modules.
    
    Pipeline:
    1. Receive brief from user
    2. Retrieve brand context (Module 5: Vector RAG)
    3. Generate creative strategy (Module 4: LLM)
    4. Generate images (Module 6: Image Generator)
    5. Generate voiceover (Module 6: Voice Generator)
    6. Compose video (Module 6: Video Composer)
    7. Apply smart editing (Module 6.5: Smart Cut)
    8. Return final content
    
    Example:
        >>> director = AIDirector(config)
        >>> brief = Brief(
        ...     brand="CoffeeLab",
        ...     product="Cold Brew",
        ...     duration=15.0,
        ...     platform="instagram"
        ... )
        >>> result = await director.create_content(brief)
    """
    
    def __init__(self, config: DirectorConfig):
        """
        Initialize AI Director.
        
        Args:
            config: Director configuration
        """
        self.config = config
        
        # Create output directories
        Path(config.output_dir).mkdir(parents=True, exist_ok=True)
        Path(config.temp_dir).mkdir(parents=True, exist_ok=True)
        
        # Initialize modules (lazy loading)
        self._rag_system = None
        self._image_generator = None
        self._voice_generator = None
        self._video_composer = None
        self._smart_cut = None
        
        logger.info("âœ… AI Director initialized")
    
    def _get_rag_system(self):
        """Lazy load Vector RAG system."""
        if self._rag_system is None:
            try:
                # Try to import Module 5
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent.parent / "module5" / "src"))
                from module5.hybrid_retriever import HybridProductionRAG
                
                self._rag_system = HybridProductionRAG(
                    method=self.config.retrieval_method,
                    top_k=self.config.top_k
                )
                logger.info("âœ… Vector RAG system loaded")
            except Exception as e:
                logger.warning(f"âš ï¸  Could not load Vector RAG: {e}")
                self._rag_system = None
        
        return self._rag_system
    
    def _get_image_generator(self):
        """Lazy load Image Generator."""
        if self._image_generator is None:
            try:
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent.parent / "module6" / "tools"))
                from image_generator import ImageGenerator
                
                self._image_generator = ImageGenerator(
                    model=self.config.image_model,
                    api_token=self.config.hf_token
                )
                logger.info("âœ… Image Generator loaded")
            except Exception as e:
                logger.warning(f"âš ï¸  Could not load Image Generator: {e}")
                self._image_generator = None
        
        return self._image_generator
    
    def _get_voice_generator(self):
        """Lazy load Voice Generator."""
        if self._voice_generator is None:
            try:
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent.parent / "module6" / "tools"))
                from voice_generator import VoiceGenerator
                
                self._voice_generator = VoiceGenerator()
                logger.info("âœ… Voice Generator loaded")
            except Exception as e:
                logger.warning(f"âš ï¸  Could not load Voice Generator: {e}")
                self._voice_generator = None
        
        return self._voice_generator
    
    def _get_video_composer(self):
        """Lazy load Video Composer."""
        if self._video_composer is None:
            try:
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent.parent / "module6" / "tools"))
                from video_composer import VideoComposer
                
                self._video_composer = VideoComposer(
                    default_fps=self.config.video_fps
                )
                logger.info("âœ… Video Composer loaded")
            except Exception as e:
                logger.warning(f"âš ï¸  Could not load Video Composer: {e}")
                self._video_composer = None
        
        return self._video_composer
    
    def _get_smart_cut(self):
        """Lazy load Smart Cut."""
        if self._smart_cut is None:
            try:
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent.parent / "module6.5" / "tools"))
                from smart_cut import SmartCut, SmartCutConfig
                
                smart_cut_config = SmartCutConfig(
                    scene_detection_method=self.config.scene_detection_method,
                    remove_silence=self.config.remove_silence
                )
                
                self._smart_cut = SmartCut(config=smart_cut_config)
                logger.info("âœ… Smart Cut loaded")
            except Exception as e:
                logger.warning(f"âš ï¸  Could not load Smart Cut: {e}")
                self._smart_cut = None
        
        return self._smart_cut
    
    async def retrieve_brand_context(self, brand: str) -> Dict[str, Any]:
        """
        Step 1: Retrieve brand context from Vector RAG.
        
        Args:
            brand: Brand name
            
        Returns:
            Brand context dictionary
        """
        logger.info(f"ðŸ” Step 1: Retrieving brand context for '{brand}'")
        
        rag = self._get_rag_system()
        
        if rag:
            try:
                results = rag.retrieve(query=f"{brand} brand guidelines")
                
                context = {
                    "brand_name": brand,
                    "documents": results,
                    "source": "Vector RAG"
                }
                
                logger.info(f"âœ… Retrieved {len(results)} brand documents")
                return context
                
            except Exception as e:
                logger.error(f"âŒ RAG retrieval failed: {e}")
        
        # Fallback: Return basic context
        logger.warning("âš ï¸  Using fallback brand context")
        return {
            "brand_name": brand,
            "documents": [],
            "source": "Fallback"
        }
    
    def generate_creative_strategy(
        self,
        brief: Brief,
        brand_context: Dict[str, Any]
    ) -> CreativeStrategy:
        """
        Step 2: Generate creative strategy using LLM.
        
        Args:
            brief: Content brief
            brand_context: Brand context from RAG
            
        Returns:
            Creative strategy
        """
        logger.info(f"ðŸ’¡ Step 2: Generating creative strategy")
        
        # TODO: Integrate with Module 4 (Fine-tuned LLM)
        # For now, use template-based strategy
        
        strategy = CreativeStrategy(
            concept=f"Premium {brief.product} showcase for {brief.platform}",
            visual_scenes=[
                f"{brief.product} on elegant surface, professional photography",
                f"Close-up of {brief.product}, dramatic lighting"
            ],
            script=self._generate_script(brief, brand_context),
            music_mood="Uplifting, modern",
            color_palette=["#2C3E50", "#ECF0F1", "#E74C3C"]
        )
        
        logger.info(f"âœ… Strategy generated: {strategy.concept}")
        return strategy
    
    def _generate_script(self, brief: Brief, context: Dict[str, Any]) -> str:
        """Generate script based on brief and context."""
        if brief.language == "thai":
            script = f"""
à¸ªà¸§à¸±à¸ªà¸”à¸µà¸„à¸£à¸±à¸š à¸§à¸±à¸™à¸™à¸µà¹‰à¹€à¸£à¸²à¸¡à¸²à¹à¸™à¸°à¸™à¸³ {brief.product} à¸ˆà¸²à¸ {brief.brand}
à¸œà¸¥à¸´à¸•à¸ à¸±à¸“à¸‘à¹Œà¸„à¸¸à¸“à¸ à¸²à¸žà¸ªà¸¹à¸‡ à¸—à¸µà¹ˆà¸•à¸­à¸šà¹‚à¸ˆà¸—à¸¢à¹Œà¸—à¸¸à¸à¸„à¸§à¸²à¸¡à¸•à¹‰à¸­à¸‡à¸à¸²à¸£
à¹€à¸£à¸´à¹ˆà¸¡à¸•à¹‰à¸™à¸›à¸£à¸°à¸ªà¸šà¸à¸²à¸£à¸“à¹Œà¸—à¸µà¹ˆà¹à¸•à¸à¸•à¹ˆà¸²à¸‡à¸à¸±à¸š {brief.brand}
            """.strip()
        else:
            script = f"""
Introducing {brief.product} from {brief.brand}
Premium quality that meets all your needs
Experience the difference with {brief.brand}
            """.strip()
        
        return script
    
    async def generate_images(
        self,
        strategy: CreativeStrategy,
        brief: Brief
    ) -> List[str]:
        """
        Step 3: Generate images for visual scenes.
        
        Args:
            strategy: Creative strategy
            brief: Content brief
            
        Returns:
            List of image file paths
        """
        logger.info(f"ðŸŽ¨ Step 3: Generating {len(strategy.visual_scenes)} images")
        
        image_gen = self._get_image_generator()
        
        if not image_gen:
            logger.error("âŒ Image Generator not available")
            return []
        
        image_paths = []
        
        for i, scene in enumerate(strategy.visual_scenes):
            try:
                output_file = Path(self.config.output_dir) / f"image_{i+1}_{int(time.time())}.png"
                
                image = image_gen.generate(
                    prompt=scene,
                    style_preset="product",
                    width=1080,
                    height=1080,
                    output_file=str(output_file)
                )
                
                image_paths.append(str(output_file))
                logger.info(f"âœ… Generated image {i+1}/{len(strategy.visual_scenes)}")
                
            except Exception as e:
                logger.error(f"âŒ Failed to generate image {i+1}: {e}")
        
        return image_paths
    
    async def generate_voiceover(
        self,
        strategy: CreativeStrategy,
        brief: Brief
    ) -> str:
        """
        Step 4: Generate voiceover from script.
        
        Args:
            strategy: Creative strategy
            brief: Content brief
            
        Returns:
            Audio file path
        """
        logger.info(f"ðŸŽ™ï¸  Step 4: Generating voiceover")
        
        voice_gen = self._get_voice_generator()
        
        if not voice_gen:
            logger.error("âŒ Voice Generator not available")
            return ""
        
        try:
            # Select voice based on language
            if brief.language == "thai":
                voice = "th-TH-NiwatNeural"
            else:
                voice = "en-US-GuyNeural"
            
            output_file = Path(self.config.output_dir) / f"voiceover_{int(time.time())}.mp3"
            
            await voice_gen.generate(
                text=strategy.script,
                voice=voice,
                rate="+0%",
                output_file=str(output_file)
            )
            
            logger.info(f"âœ… Voiceover generated: {output_file}")
            return str(output_file)
            
        except Exception as e:
            logger.error(f"âŒ Failed to generate voiceover: {e}")
            return ""
    
    def compose_video(
        self,
        images: List[str],
        audio: str,
        brief: Brief
    ) -> str:
        """
        Step 5: Compose video from images and audio.
        
        Args:
            images: List of image paths
            audio: Audio file path
            brief: Content brief
            
        Returns:
            Video file path
        """
        logger.info(f"ðŸŽ¬ Step 5: Composing video")
        
        video_comp = self._get_video_composer()
        
        if not video_comp:
            logger.error("âŒ Video Composer not available")
            return ""
        
        try:
            output_file = Path(self.config.output_dir) / f"video_raw_{int(time.time())}.mp4"
            
            video = video_comp.create_ad(
                images=images,
                audio=audio,
                duration=brief.duration,
                title=f"{brief.brand} - {brief.product}",
                style="minimal"
            )
            
            video_comp.export(
                video=video,
                output_file=str(output_file),
                fps=self.config.video_fps
            )
            
            logger.info(f"âœ… Video composed: {output_file}")
            return str(output_file)
            
        except Exception as e:
            logger.error(f"âŒ Failed to compose video: {e}")
            return ""
    
    def apply_smart_editing(
        self,
        video_path: str,
        brief: Brief
    ) -> str:
        """
        Step 6: Apply smart editing to video.
        
        Args:
            video_path: Input video path
            brief: Content brief
            
        Returns:
            Edited video path
        """
        logger.info(f"âœ‚ï¸  Step 6: Applying smart editing")
        
        smart_cut = self._get_smart_cut()
        
        if not smart_cut:
            logger.warning("âš ï¸  Smart Cut not available, skipping")
            return video_path
        
        try:
            output_file = Path(self.config.output_dir) / f"video_final_{int(time.time())}.mp4"
            
            result = smart_cut.process_video(
                input_path=video_path,
                output_path=str(output_file),
                remove_silence=self.config.remove_silence,
                target_duration=brief.duration
            )
            
            logger.info(f"âœ… Smart editing applied: {output_file}")
            logger.info(f"   Time saved: {result['time_saved']:.2f}s")
            
            return str(output_file)
            
        except Exception as e:
            logger.error(f"âŒ Smart editing failed: {e}")
            return video_path
    
    async def create_content(self, brief: Brief) -> ContentOutput:
        """
        Create content from brief (full pipeline).
        
        Args:
            brief: Content brief
            
        Returns:
            Content output
        """
        logger.info(f"\n{'='*60}")
        logger.info(f"ðŸŽ¬ AI DIRECTOR: Creating content for {brief.brand}")
        logger.info(f"{'='*60}\n")
        
        start_time = time.time()
        
        # Step 1: Retrieve brand context
        brand_context = await self.retrieve_brand_context(brief.brand)
        
        # Step 2: Generate creative strategy
        strategy = self.generate_creative_strategy(brief, brand_context)
        
        # Step 3: Generate images
        images = await self.generate_images(strategy, brief)
        
        # Step 4: Generate voiceover
        audio = await self.generate_voiceover(strategy, brief)
        
        # Step 5: Compose video
        video_raw = self.compose_video(images, audio, brief)
        
        # Step 6: Apply smart editing
        video_final = self.apply_smart_editing(video_raw, brief)
        
        # Calculate duration
        total_time = time.time() - start_time
        
        # Create output
        output = ContentOutput(
            video_path=video_final,
            images=images,
            audio_path=audio,
            duration=brief.duration,
            metadata={
                "brief": brief.to_dict(),
                "strategy": strategy.to_dict(),
                "brand_context": brand_context,
                "processing_time": total_time,
                "timestamp": datetime.now().isoformat()
            }
        )
        
        # Save metadata
        metadata_path = Path(video_final).with_suffix(".json")
        with open(metadata_path, "w") as f:
            json.dump(output.to_dict(), f, indent=2)
        
        logger.info(f"\n{'='*60}")
        logger.info(f"âœ… CONTENT CREATED SUCCESSFULLY!")
        logger.info(f"{'='*60}")
        logger.info(f"   Video: {video_final}")
        logger.info(f"   Duration: {brief.duration}s")
        logger.info(f"   Processing time: {total_time:.2f}s")
        logger.info(f"{'='*60}\n")
        
        return output


# Example usage
if __name__ == "__main__":
    import asyncio
    import os
    
    async def main():
        # Configure
        config = DirectorConfig(
            mongodb_uri=os.getenv("MONGODB_URI"),
            hf_token=os.getenv("HF_TOKEN"),
            output_dir="output/integration_test"
        )
        
        # Initialize director
        director = AIDirector(config)
        
        # Create brief
        brief = Brief(
            brand="CoffeeLab",
            product="Cold Brew Premium",
            duration=15.0,
            platform="instagram",
            language="thai",
            tone="premium"
        )
        
        # Create content
        result = await director.create_content(brief)
        
        print(f"\nâœ… Content created: {result.video_path}")
    
    asyncio.run(main())
