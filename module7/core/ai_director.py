"""
Module 7: AI Director Orchestrator
==================================

Main orchestrator that coordinates all AI Director modules.

Components:
- Module 4: LLM (Fine-tuned model for strategy generation)
- Module 5: Vector RAG (Brand context retrieval)
- Module 6: Production Tools (Image/Voice/Video generation)
- Module 6.5: Smart Cut (Video editing)

Author: AI Director Team
License: MIT
"""

import logging
from typing import Dict, Any, Optional, List
from pathlib import Path
import json
import time
import os
from dataclasses import dataclass, asdict
from datetime import datetime

# Import LLM integration
from .llm_integration import get_llm_engine

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)


@dataclass
class DirectorConfig:
    """Configuration for AI Director."""
    # Module 5: Vector RAG
    mongodb_uri: Optional[str] = None
    mongodb_database: str = "ai_director"
    mongodb_collection: str = "brand_vectors"
    retrieval_method: str = "hybrid"  # "vector", "bm25", "hybrid"
    top_k: int = 3
    
    # Module 6: Production Tools
    hf_token: Optional[str] = None
    image_model: str = "sdxl"
    voice_language: str = "thai"
    video_fps: int = 30
    
    # Module 6.5: Smart Cut
    scene_detection_method: str = "content"
    remove_silence: bool = True
    
    # General
    output_dir: str = "output"
    temp_dir: str = "temp"
    cache_enabled: bool = False
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert config to dictionary."""
        return asdict(self)


@dataclass
class Brief:
    """Content brief from user."""
    brand: str
    product: str
    duration: float  # seconds
    platform: str  # "instagram", "youtube", "tiktok", etc.
    language: str = "thai"
    tone: str = "professional"
    additional_notes: Optional[str] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert brief to dictionary."""
        return asdict(self)


@dataclass
class CreativeStrategy:
    """Creative strategy generated by LLM."""
    concept: str
    visual_scenes: List[str]  # Image generation prompts
    script: str  # Full advertising script (deprecated, use voiceover_script)
    voiceover_script: str  # Actual advertising copy for narration
    music_mood: Optional[str] = None
    color_palette: Optional[List[str]] = None
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert strategy to dictionary."""
        return asdict(self)


@dataclass
class ContentOutput:
    """Final content output."""
    video_path: str
    images: List[str]
    audio_path: str
    duration: float
    metadata: Dict[str, Any]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert output to dictionary."""
        return asdict(self)


class AIDirector:
    """
    AI Director Orchestrator - Coordinates all modules.
    
    Pipeline:
    1. Receive brief from user
    2. Retrieve brand context (Module 5: Vector RAG)
    3. Generate creative strategy (Module 4: LLM)
    4. Generate images (Module 6: Image Generator)
    5. Generate voiceover (Module 6: Voice Generator)
    6. Compose video (Module 6: Video Composer)
    7. Apply smart editing (Module 6.5: Smart Cut)
    8. Return final content
    
    Example:
        >>> director = AIDirector(config)
        >>> brief = Brief(
        ...     brand="CoffeeLab",
        ...     product="Cold Brew",
        ...     duration=15.0,
        ...     platform="instagram"
        ... )
        >>> result = await director.create_content(brief)
    """
    
    def __init__(self, config: DirectorConfig):
        """
        Initialize AI Director.
        
        Args:
            config: Director configuration
        """
        self.config = config
        
        # Create output directories
        Path(config.output_dir).mkdir(parents=True, exist_ok=True)
        Path(config.temp_dir).mkdir(parents=True, exist_ok=True)
        
        # Initialize modules (lazy loading)
        self._rag_system = None
        self._image_generator = None
        self._voice_generator = None
        self._video_composer = None
        self._smart_cut = None
        
        logger.info("‚úÖ AI Director initialized")
    
    def _get_rag_system(self):
        """Lazy load Vector RAG system."""
        if self._rag_system is None:
            try:
                # Try to import Module 5
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent.parent / "module5" / "src"))
                from module5.hybrid_retriever import HybridProductionRAG
                
                self._rag_system = HybridProductionRAG(
                    method=self.config.retrieval_method,
                    top_k=self.config.top_k
                )
                logger.info("‚úÖ Vector RAG system loaded")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è  Could not load Vector RAG: {e}")
                self._rag_system = None
        
        return self._rag_system
    
    def _get_image_generator(self):
        """Lazy load Image Generator - prioritize Replicate API."""
        if self._image_generator is None:
            try:
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent.parent / "module6" / "tools"))
                
                # Try Replicate first (has free tier)
                try:
                    from replicate_image_generator import ReplicateImageGenerator
                    replicate_token = os.environ.get("REPLICATE_API_TOKEN")
                    
                    self._image_generator = ReplicateImageGenerator(
                        model="sdxl",
                        api_token=replicate_token
                    )
                    logger.info("‚úÖ Replicate Image Generator loaded")
                except Exception as e:
                    logger.warning(f"‚ö†Ô∏è  Replicate not available: {e}, trying HuggingFace...")
                    
                    # Fallback to HuggingFace
                    from image_generator import ImageGenerator
                    
                    self._image_generator = ImageGenerator(
                        model=self.config.image_model,
                        api_token=self.config.hf_token
                    )
                    logger.info("‚úÖ HuggingFace Image Generator loaded (fallback)")
                    
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è  Could not load any Image Generator: {e}")
                self._image_generator = None
        
        return self._image_generator
    
    def _get_voice_generator(self):
        """Lazy load Voice Generator."""
        if self._voice_generator is None:
            try:
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent.parent / "module6" / "tools"))
                from voice_generator import VoiceGenerator
                
                self._voice_generator = VoiceGenerator()
                logger.info("‚úÖ Voice Generator loaded")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è  Could not load Voice Generator: {e}")
                self._voice_generator = None
        
        return self._voice_generator
    
    def _get_video_composer(self):
        """Lazy load Video Composer."""
        if self._video_composer is None:
            try:
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent.parent / "module6" / "tools"))
                from video_composer import VideoComposer
                
                self._video_composer = VideoComposer(
                    default_fps=self.config.video_fps
                )
                logger.info("‚úÖ Video Composer loaded")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è  Could not load Video Composer: {e}")
                self._video_composer = None
        
        return self._video_composer
    
    def _get_smart_cut(self):
        """Lazy load Smart Cut."""
        if self._smart_cut is None:
            try:
                import sys
                sys.path.insert(0, str(Path(__file__).parent.parent.parent / "module6.5" / "tools"))
                from smart_cut import SmartCut, SmartCutConfig
                
                smart_cut_config = SmartCutConfig(
                    scene_detection_method=self.config.scene_detection_method,
                    remove_silence=self.config.remove_silence
                )
                
                self._smart_cut = SmartCut(config=smart_cut_config)
                logger.info("‚úÖ Smart Cut loaded")
            except Exception as e:
                logger.warning(f"‚ö†Ô∏è  Could not load Smart Cut: {e}")
                self._smart_cut = None
        
        return self._smart_cut
    
    async def retrieve_brand_context(self, brand: str) -> Dict[str, Any]:
        """
        Step 1: Retrieve brand context from Vector RAG.
        
        Args:
            brand: Brand name
            
        Returns:
            Brand context dictionary
        """
        logger.info(f"üîç Step 1: Retrieving brand context for '{brand}'")
        
        rag = self._get_rag_system()
        
        if rag:
            try:
                results = rag.retrieve(query=f"{brand} brand guidelines")
                
                context = {
                    "brand_name": brand,
                    "documents": results,
                    "source": "Vector RAG"
                }
                
                logger.info(f"‚úÖ Retrieved {len(results)} brand documents")
                return context
                
            except Exception as e:
                logger.error(f"‚ùå RAG retrieval failed: {e}")
        
        # Fallback: Return basic context
        logger.warning("‚ö†Ô∏è  Using fallback brand context")
        return {
            "brand_name": brand,
            "documents": [],
            "source": "Fallback"
        }
    
    def generate_creative_strategy(
        self,
        brief: Brief,
        brand_context: Dict[str, Any]
    ) -> CreativeStrategy:
        """
        Step 2: Generate creative strategy using LLM.
        
        Args:
            brief: Content brief
            brand_context: Brand context from RAG
            
        Returns:
            Creative strategy
        """
        logger.info(f"üí° Step 2: Generating creative strategy")
        
        # üöÄ Use Module 4 LLM Integration
        try:
            llm_engine = get_llm_engine()
            
            # Extract brand context text
            context_text = None
            if brand_context and 'documents' in brand_context:
                docs = brand_context['documents']
                if docs and len(docs) > 0:
                    context_text = "\n".join([doc.get('content', '') for doc in docs[:3]])
            
            # Generate strategy with LLM
            strategy_dict = llm_engine.generate_strategy(
                product=brief.product,
                brand=brief.brand,
                tone=brief.tone,
                platform=brief.platform,
                duration=brief.duration,
                language=brief.language,
                brand_context=context_text
            )
            
            # Convert to CreativeStrategy object
            strategy = CreativeStrategy(
                concept=strategy_dict.get('core_message', f"Premium {brief.product} showcase"),
                visual_scenes=strategy_dict.get('visual_scenes', []),
                script=strategy_dict.get('script_outline', []),
                voiceover_script=strategy_dict.get('voiceover_script', ''),  # ‚úÖ Actual ad copy
                music_mood="Uplifting, modern, inspiring",
                color_palette=["#2C3E50", "#ECF0F1", "#E74C3C", "#3498DB", "#27AE60"]
            )
            
            generation_method = strategy_dict.get('generation_method', 'llm')
            logger.info(f"‚úÖ Strategy generated via {generation_method}: {strategy.concept} ({len(strategy.visual_scenes)} scenes)")
            
            return strategy
            
        except Exception as e:
            logger.error(f"‚ùå Failed to generate strategy: {e}")
            # Return minimal valid strategy
            return CreativeStrategy(
                concept=f"Professional {brief.product} presentation",
                visual_scenes=[
                    f"Professional showcase of {brief.product}",
                    f"Detail highlights of {brief.product}",
                    f"Lifestyle context for {brief.product}"
                ],
                script=["Introduction", "Features", "Benefits", "Call to Action"],
                voiceover_script=f"Introducing {brief.product}. Experience innovation and quality. Available now.",  # ‚úÖ Fallback ad copy
                music_mood="Professional, engaging",
                color_palette=["#2C3E50", "#ECF0F1", "#3498DB"]
            )
    
    def _generate_visual_scenes(self, brief: Brief, num_scenes: int) -> List[str]:
        """Generate detailed visual scene prompts using professional prompt engineering."""
        
        # Import prompt engineer
        try:
            from .prompt_templates import generate_visual_scenes
            
            # Generate professional prompts
            scenes = generate_visual_scenes(
                product=brief.product,
                brand=brief.brand,
                tone=brief.tone,
                platform=brief.platform,
                duration=brief.duration,
                language=brief.language
            )
            
            logger.info(f"‚úÖ Generated {len(scenes)} professional visual prompts")
            return scenes
            
        except Exception as e:
            logger.warning(f"‚ö†Ô∏è  Prompt engineer failed, using fallback: {e}")
            
            # Fallback to enhanced templates
            product = brief.product
            tone = brief.tone
            
            # Enhanced prompts with more detail
            scene_templates = [
                f"Cinematic hero shot of {product}, floating in air, dramatic lighting, premium commercial photography, 8k, hyper realistic, {tone} atmosphere, award winning, masterpiece",
                f"Close-up product photography of {product}, studio lighting, elegant composition, shallow depth of field, professional advertising, luxury brand aesthetic, highly detailed, photorealistic",
                f"Dynamic action shot of {product} in motion, speed blur effect, cinematic color grading, high-end commercial, dramatic shadows and highlights, professional quality, 8k",
                f"Lifestyle photography featuring {product} in premium environment, natural lighting, aspirational setting, editorial style, magazine quality, emotional storytelling, authentic",
                f"Artistic overhead view of {product}, minimalist composition, bold colors, modern design aesthetic, creative advertising photography, rule of thirds, perfect balance",
                f"Epic wide angle shot of {product} in dramatic setting, golden hour lighting, cinematic atmosphere, high production value, {tone} mood, trending on artstation",
                f"Detail macro shot highlighting {product} features, professional product photography, clean background, perfect lighting, commercial quality, sharp focus, depth of field",
                f"Environmental portrait of {product} in context, storytelling composition, atmospheric lighting, premium brand photography, emotional connection, aspirational lifestyle"
            ]
            
            # Select scenes based on number needed
            selected_scenes = scene_templates[:num_scenes]
            
            # If need more scenes, repeat with variations
            while len(selected_scenes) < num_scenes:
                idx = len(selected_scenes) % len(scene_templates)
                variation = f"{scene_templates[idx]}, alternative angle, different composition"
                selected_scenes.append(variation)
            
            return selected_scenes[:num_scenes]
    
    def _generate_script(self, brief: Brief, context: Dict[str, Any]) -> str:
        """Generate script based on brief and context."""
        if brief.language == "thai":
            script = f"""
‡∏™‡∏ß‡∏±‡∏™‡∏î‡∏µ‡∏Ñ‡∏£‡∏±‡∏ö ‡∏ß‡∏±‡∏ô‡∏ô‡∏µ‡πâ‡πÄ‡∏£‡∏≤‡∏°‡∏≤‡πÅ‡∏ô‡∏∞‡∏ô‡∏≥ {brief.product} ‡∏à‡∏≤‡∏Å {brief.brand}
‡∏ú‡∏•‡∏¥‡∏ï‡∏†‡∏±‡∏ì‡∏ë‡πå‡∏Ñ‡∏∏‡∏ì‡∏†‡∏≤‡∏û‡∏™‡∏π‡∏á ‡∏ó‡∏µ‡πà‡∏ï‡∏≠‡∏ö‡πÇ‡∏à‡∏ó‡∏¢‡πå‡∏ó‡∏∏‡∏Å‡∏Ñ‡∏ß‡∏≤‡∏°‡∏ï‡πâ‡∏≠‡∏á‡∏Å‡∏≤‡∏£
‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏õ‡∏£‡∏∞‡∏™‡∏ö‡∏Å‡∏≤‡∏£‡∏ì‡πå‡∏ó‡∏µ‡πà‡πÅ‡∏ï‡∏Å‡∏ï‡πà‡∏≤‡∏á‡∏Å‡∏±‡∏ö {brief.brand}
            """.strip()
        else:
            script = f"""
Introducing {brief.product} from {brief.brand}
Premium quality that meets all your needs
Experience the difference with {brief.brand}
            """.strip()
        
        return script
    
    async def generate_images(
        self,
        strategy: CreativeStrategy,
        brief: Brief
    ) -> List[str]:
        """
        Step 3: Generate images for visual scenes.
        
        Args:
            strategy: Creative strategy
            brief: Content brief
            
        Returns:
            List of image file paths
        """
        logger.info(f"üé® Step 3: Generating {len(strategy.visual_scenes)} images")
        
        image_gen = self._get_image_generator()
        
        if not image_gen:
            logger.error("‚ùå Image Generator not available")
            return []
        
        image_paths = []
        
        for i, scene in enumerate(strategy.visual_scenes):
            try:
                output_file = Path(self.config.output_dir) / f"image_{i+1}_{int(time.time())}.png"
                
                image = image_gen.generate(
                    prompt=scene,
                    style_preset="product",
                    width=1080,
                    height=1080,
                    output_file=str(output_file)
                )
                
                image_paths.append(str(output_file))
                logger.info(f"‚úÖ Generated image {i+1}/{len(strategy.visual_scenes)}")
                
            except Exception as e:
                logger.error(f"‚ùå Failed to generate image {i+1}: {e}")
        
        return image_paths
    
    async def generate_voiceover(
        self,
        strategy: CreativeStrategy,
        brief: Brief
    ) -> str:
        """
        Step 4: Generate voiceover from script.
        
        Args:
            strategy: Creative strategy
            brief: Content brief
            
        Returns:
            Audio file path
        """
        logger.info(f"üéôÔ∏è  Step 4: Generating voiceover")
        
        voice_gen = self._get_voice_generator()
        
        if not voice_gen:
            logger.error("‚ùå Voice Generator not available")
            return ""
        
        try:
            # Select voice based on language
            if brief.language == "thai":
                voice = "th-TH-NiwatNeural"
            else:
                voice = "en-US-GuyNeural"
            
            output_file = Path(self.config.output_dir) / f"voiceover_{int(time.time())}.mp3"
            
            await voice_gen.generate(
                text=strategy.script,
                voice=voice,
                rate="+0%",
                output_file=str(output_file)
            )
            
            logger.info(f"‚úÖ Voiceover generated: {output_file}")
            return str(output_file)
            
        except Exception as e:
            logger.error(f"‚ùå Failed to generate voiceover: {e}")
            return ""
    
    def compose_video(
        self,
        images: List[str],
        audio: str,
        brief: Brief
    ) -> str:
        """
        Step 5: Compose video from images and audio.
        
        Args:
            images: List of image paths
            audio: Audio file path
            brief: Content brief
            
        Returns:
            Video file path
        """
        logger.info(f"üé¨ Step 5: Composing video")
        
        video_comp = self._get_video_composer()
        
        if not video_comp:
            logger.error("‚ùå Video Composer not available")
            return ""
        
        try:
            output_file = Path(self.config.output_dir) / f"video_raw_{int(time.time())}.mp4"
            
            video = video_comp.create_ad(
                images=images,
                audio=audio,
                duration=brief.duration,
                title=f"{brief.brand} - {brief.product}",
                style="minimal"
            )
            
            video_comp.export(
                video=video,
                output_file=str(output_file),
                fps=self.config.video_fps
            )
            
            logger.info(f"‚úÖ Video composed: {output_file}")
            return str(output_file)
            
        except Exception as e:
            logger.error(f"‚ùå Failed to compose video: {e}")
            return ""
    
    def apply_smart_editing(
        self,
        video_path: str,
        brief: Brief
    ) -> str:
        """
        Step 6: Apply smart editing to video.
        
        Args:
            video_path: Input video path
            brief: Content brief
            
        Returns:
            Edited video path
        """
        logger.info(f"‚úÇÔ∏è  Step 6: Applying smart editing")
        
        smart_cut = self._get_smart_cut()
        
        if not smart_cut:
            logger.warning("‚ö†Ô∏è  Smart Cut not available, skipping")
            return video_path
        
        try:
            output_file = Path(self.config.output_dir) / f"video_final_{int(time.time())}.mp4"
            
            result = smart_cut.process_video(
                input_path=video_path,
                output_path=str(output_file),
                remove_silence=self.config.remove_silence,
                target_duration=brief.duration
            )
            
            logger.info(f"‚úÖ Smart editing applied: {output_file}")
            logger.info(f"   Time saved: {result['time_saved']:.2f}s")
            
            return str(output_file)
            
        except Exception as e:
            logger.error(f"‚ùå Smart editing failed: {e}")
            return video_path
    
    async def create_content(self, brief: Brief) -> ContentOutput:
        """
        Create content from brief (full pipeline).
        
        Args:
            brief: Content brief
            
        Returns:
            Content output
        """
        logger.info(f"\n{'='*60}")
        logger.info(f"üé¨ AI DIRECTOR: Creating content for {brief.brand}")
        logger.info(f"{'='*60}\n")
        
        start_time = time.time()
        
        # Step 1: Retrieve brand context
        brand_context = await self.retrieve_brand_context(brief.brand)
        
        # Step 2: Generate creative strategy
        strategy = self.generate_creative_strategy(brief, brand_context)
        
        # Step 3: Generate images
        images = await self.generate_images(strategy, brief)
        
        # Step 4: Generate voiceover
        audio = await self.generate_voiceover(strategy, brief)
        
        # Step 5: Compose video
        video_raw = self.compose_video(images, audio, brief)
        
        # Step 6: Apply smart editing
        video_final = self.apply_smart_editing(video_raw, brief)
        
        # Calculate duration
        total_time = time.time() - start_time
        
        # Create output
        output = ContentOutput(
            video_path=video_final,
            images=images,
            audio_path=audio,
            duration=brief.duration,
            metadata={
                "brief": brief.to_dict(),
                "strategy": strategy.to_dict(),
                "brand_context": brand_context,
                "processing_time": total_time,
                "timestamp": datetime.now().isoformat()
            }
        )
        
        # Save metadata
        metadata_path = Path(video_final).with_suffix(".json")
        with open(metadata_path, "w") as f:
            json.dump(output.to_dict(), f, indent=2)
        
        logger.info(f"\n{'='*60}")
        logger.info(f"‚úÖ CONTENT CREATED SUCCESSFULLY!")
        logger.info(f"{'='*60}")
        logger.info(f"   Video: {video_final}")
        logger.info(f"   Duration: {brief.duration}s")
        logger.info(f"   Processing time: {total_time:.2f}s")
        logger.info(f"{'='*60}\n")
        
        return output


# Example usage
if __name__ == "__main__":
    import asyncio
    import os
    
    async def main():
        # Configure
        config = DirectorConfig(
            mongodb_uri=os.getenv("MONGODB_URI"),
            hf_token=os.getenv("HF_TOKEN"),
            output_dir="output/integration_test"
        )
        
        # Initialize director
        director = AIDirector(config)
        
        # Create brief
        brief = Brief(
            brand="CoffeeLab",
            product="Cold Brew Premium",
            duration=15.0,
            platform="instagram",
            language="thai",
            tone="premium"
        )
        
        # Create content
        result = await director.create_content(brief)
        
        print(f"\n‚úÖ Content created: {result.video_path}")
    
    asyncio.run(main())
